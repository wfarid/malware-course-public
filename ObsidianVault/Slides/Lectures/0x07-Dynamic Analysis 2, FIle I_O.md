---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::


---
<!-- slide template="[[Title Slide]]" -->
 ## Lecture 0x07
 Dynamic Analysis Continued Files & I/O 
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Review: Kernel Objects

:::

<!-- element style="font-size: 24px"-->
- Objects are created and managed by the 
Kernel Object Manager
- The Object Manager lives in kernel 
space and is beyond the scope of this lecture. That said…
- The object manager maintains a count of the number of references to an object. 
- When an object is created, the object manager sets the object's reference count to one. 
- Once that counter falls to zero, the object is freed.
- When a processes ends (or crashes), all of its handles are destroyed 
- Creating an object usually involves a win32 api call Create[ObjectName]

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Why do we interact with Objects via Handles?
:::

::: left
<!-- element style="font-size: 22px"-->
- If you mess something up in a processes, it might hoard resources/crash. The resources used by the process are cleaned up when it terminates. 
- If you mess something up in kernel space, resources might be locked until a reboot, or you could get an instant BSOD.
- Access control is also a plus


:::

::: right
![[0x08_slide_4_image.png|500]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### More on Kernel Objects		

:::

<!-- element style="font-size: 24px"-->
- The Object Manager is 
responsible
 for (among other things)
- Creation and destruction of objects
- Controlling access
- Maintaining
 a list of which processes is using what object
- Managing
 object lifetimes: i.e. when is it safe to auto-destroy an object?


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Kernel Object Examples

:::

<!-- element style="font-size: 24px"-->
- Files
- Threads
- Processes
- Devices
- Mutexes
- Symbolic links 
- Access Tokens 


---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Viewing Handle Usage
:::


![[0x08_slide_7_image.png|600]]


---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Example:
:::

- `.\handle64.exe  -p brave.exe`

![[0x08_slide_8_image.png|500]]

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Process Explorer 
:::

::: left
<!-- element style="font-size: 24px"-->
- Task manager on steroids
- Provides information about processes, parent/child relationships, Handles, DLLs, in memory strings… and more!
- To View handle we click 


:::

::: right
![[0x08_slide_9_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Dynamic Analysis with Sysinternals 
:::

![[0x08_slide_10_image.png]]




---
<!-- slide template="[[Base Slide]]" -->
::: title
#### File Objects  

:::

<!-- element style="font-size: 24px"-->
- File Objects are a type of Kernel Object
- 
  File objects function as the logical interface between kernel and user-mode processes and the file data that resides on the physical disk.”  
- File Object != Disk file, but all  disk files are File Objects
- Files on the filesystem  (most of the time) are actually symbolic links to some file saved on a physical disk
- File handles are **very** similar to Filde Descriptors 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### The Windows I/O System

:::

<!-- element style="font-size: 22px"-->
- Any (useful) operating system needs to be able to interact with external entities called “devices”
- I.e., send and recieve data to external devices. 
- For example, our PCs wouldn’t be very useful to us without the ability to send keystrokes via a keyboard, and have the computer display output to the screen
- A driver provides a software interface for the exchange of data between  a device and the OS
- "The Windows I/O manager is a kernel feature that “manages the communication between applications and the interfaces provided by device drivers”
- In other words, the IO system abstracts away complicated, and 
dangerous  parts of performing I/O  on physical and logical devices  


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Windows I/O system: Userland perspective 

:::

<!-- element style="font-size: 24px"-->
- Userland processes call into the I/O system using the Windows (or Native) API
- Any File I/O operation is initiated by a kernel mode 
entity
 within the I/O system called the 
I/O Manager
- In order to initiate this processes, the Native API invokes a 
syscall
- Recall that a syscall is the lowest 
level
, userland function 
available
 to us: this allows userland processes to call into Kernel space via an API

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### The Windows File system 
:::

::: left
<!-- element style="font-size: 24px"-->
- From the perspective of an application/user, files are organized in a Tree structure
- There are many 
different
 types of files, but the basic ones are directories, and Regular files 
- Directories can have child nodes
- Regular files cannot have child nodes 


:::

::: right
![[meta-file-meme.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### File Paths 

:::

<!-- element style="font-size: 24px"-->
- Unix Paths start at the root directory “/”
- A path is either a relative or absolute path to a file
- Example: “../folder_a/file_a.txt” is a relative path 
- “..” is the previous directory one level out
- “.” is the current directory
- Example: “/home/remnux/Desktop/inetsim.conf” is an absolute path to a file 
- On Windows, we use “\\” as opposed to “/”  for a path 
separator
- There is also a logical drive name (usually a letter)

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Tree Structure 
:::

::: left
<!-- element style="font-size: 24px"-->
- `tree /f .` creates an ASCII art tree representation of the tree structure with root node equal to the current directory
- It then “Walks” the tree and 
displays
 all files and directories  


:::

::: right

```
tree/f
Folder PATH listing
Volume serial number is 3665-CD06
C:.
│   1234
│   echo.dll
│   foo.txt
│   t.exe
│   test.dll
│   x32dbg.lnk
│   x64dbg.lnk
│   
└───foo
        asdf.txt

```

:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Directory Tree
:::

::: left
<!-- element style="font-size: 24px"-->
- Paths are always paths on a tree
- The path is mapped to an actual physical path
- The kernel handles a lot of complicated tasks such as Disk IO, power 
management
, …etc 


:::

::: right
![[0x08_slide_17_image.png]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Symbolic Links 
:::

::: left
<!-- element style="font-size: 24px"-->
- A symbolic link is an alias for a symbolic link target
- On Windows, we usually pass symbolic links as arguments to functions
- Logical drives like C:\ are actually symbolic links to (usually) volumes on a disk
- WinObj64 is a sysinternals tool that allows us to view Kernel objects including Symbolic links  


:::

::: right
![[0x08_slide_18_image.png]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Linux Devices
:::
`/dev/<device>`  --> `/`
i.e., `/dev/sda`


---
<!-- slide template="[[Base Slide]]" -->
::: title 
#### View Devices on Windows
:::
![[Pasted image 20230203095224.png]]
---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### C:\ is a symbolic link
:::
![[Pasted image 20240205110351.png]]

:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Terminology: Files 

:::

<!-- element style="font-size: 24px"-->
- In this class, we will use the following Convention for talking about File Objects:
- File: What you normally think of when someone says a file. I.e., something with a symbolic link on disk. 
- File Object: A kernel object 
- If I say File, I mean a file on disk
- If I say File Object, I am 
referring
 to a Kernel Object


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Getting a Handle to a File Object

:::

<!-- element style="font-size: 24px"-->
- `CreateFile(A||W)`: Win32 call to create a handle to a File Object. Supports all versions of Windows. 
- `CreateFile2`: Similar to CreateFileW, but can be called from a special type of Application called a Universal Windows Platform (UWP). Is only supported on Windows 8 and above
- `NtCreateFile`: Native API call to create a File Object. All of the functions above call into it!
- CRT (`fopen`) POSIX flavor c runtime API also returns a File Object

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### CreateFileA  

:::

<!-- element style="font-size: 28px"-->
```c++
HANDLE CreateFileA(
  [in]           LPCSTR                lpFileName,
  [in]           DWORD                 dwDesiredAccess,
  [in]           DWORD                 dwShareMode,
  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  [in]           DWORD                 dwCreationDisposition,
  [in]           DWORD                 dwFlagsAndAttributes,
  [in, optional] HANDLE                hTemplateFile
);
```
- Demo: reading the Docs 
- https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Creating a File Object
:::

::: left
<!-- element style="font-size: 24px"-->
- CreateFileA→NtCreateFile→Kernel Magic
- I/O 
System abstraction

:::

::: right
![[0x08_slide_23_image.png]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Kernel Magic is Magical  
:::


![[0x08_slide_24_image.png]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### NtCreateFile 
:::

::: left
<!-- element style="font-size: 20px"-->
` 00007FFE8C5ED812 | 0F05  | syscall | NtCreateFile`


:::

::: right
![[0x08_slide_25_image.png| 800px]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Mapping Symbolic Links to Target paths 

:::
```c++
DWORD  QueryDosDeviceA(
   [in, optional] LPCSTR lpDeviceName,
   [out]          LPSTR  lpTargetPath,
   [in]           DWORD  ucchMax);
```

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Querying File Information
:::

::: left
<!-- element style="font-size: 24px"-->
- Calculating the File Size 
- Reading/modifying file “times”
- Reading/modifying File Attributes 
- How? You will figure it out on your homework :D 


:::

::: right
![[0x08_slide_27_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### File Attributes 

:::

<!-- element style="font-size: 22px"-->
- Metadata associated with file objects 
committed
 to disk
- When creating Files, you can control these 
attributes with File Attribute masks
- Examples: 
	- `FILE_ATTRIBUTE_NORMAL`
 The mask you use for normal files
	- `FILE_ATTRIBUTE_DIRECTORY `
The file is a directory
	- `FILE_ATTRIBUTE_HIDDEN `
The file is hidden
	- `FILE_ATTRIBUTE_NOT_CONTENT_INDEXED` 
The file won’t be indexed
	- `FILE_ATTRIBUTE_READONLY`  
The file is read only.
	- `FILE_ATTRIBUTE_TEMPORARY`
File attempts to stay in memory.
- Full:
https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Common Footguns
:::

::: left
<!-- element style="font-size: 24px"-->
- DWORD is an unsigned 32 bit 
integer
- When Windows NT was first rolled out, the thought of having lots of files larger than $2^{32}$ bytes was a bit of an insane/edge case prospect 
:::

::: right
![[Pasted image 20240205110707.png]]

:::
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Footguns Continued
:::
<!-- element style="font-size: 24px"-->
- $2^{32}$ bytes is about 4.3 Gigabytes
- On the other hand, $2^{64}$ bytes is about 1.8 * 10^10 gigabytes
	- Or 18,446,744.1 terabytes. That is pretty large. For now, 64bit 
unsigned  integers should be sufficient to house file sizes
- GetFileSize  returns a 32bit unsigned integer
- If it is larger than 4GBs, then you need to use lpFileSizeHigh
- If you set lpFileSizeHigh to null, and fs>4gb…you will have a bad time
- Please use GetFileSizeEx 
- Example: Ransomware F\*ck ups

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Synchronous File IO

:::

<!-- element style="font-size: 24px"-->
- Windows performs I/O asynchronously under the hood
- That said, async I/O is considerably more complicated than Synchronous I/O
- Here synchronous means the thread performing I/O is blocked (in a waiting state) until the I/O is completed
- Async allows the the thread to go do other work while it waits for the I/O to finish 
- For now, we will only look at Synchronous I/O


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### File I/O: Reading 
:::

::: left
<!-- element style="font-size: 20px"-->
- Like everything 
involving
 I/O, we first call CreateFile
- You should then determine the size of the file
- Allocate a buffer large enough to fit all of the data.
	- If the data is to be interpreted as a string, make sure to have enough space for an added null byte
	- If the file is Unicode encoded, make sure to have enough space for  a wide char null terminator!


:::

::: right
![[Pasted image 20240205110851.png]]

:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Remarks on Memory Allocation

:::

<!-- element style="font-size: 24px"-->
- We will dedicate more time to this later on in the class, but you should currently be familiar with C-runtime style memory 
management
. I.e., `malloc` `free` 
- C++: new/delete
	- Where as `malloc` only lets you allocate in terms of bytes, new lets you allocate space according to an objects type!
	- I.e., malloc(sizeof(int) * 100) vs new int[100];  
- Modern C++: Smart pointers 
	- `<memory>--> std::make_unique ← smart pointer` that is automatically freed once the object goes out of scope!


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Question: Reading Files

:::

<!-- element style="font-size: 24px"-->
- If we want to read a 
file into
 memory and print its contents, do we use stack or heap memory? 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Answer:	

:::

<!-- element style="font-size: 24px"-->
- Either :smile: . Heap is more flexible, and can handle arbitrary files. 
- Stack can read a file in chunks, or have some maximum size file. 
- ….but you should still use Heap memory :-)



---
<!-- slide template="[[Title Slide]]" -->
 ## Demo: 
Reading a file
C, C++, Modern c++
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### File IO/ Writing 

:::

<!-- element style="font-size: 24px"-->
- Let’s figure it out together!


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Procmon: Looking at File operations 

:::

<!-- element style="font-size: 24px"-->
- Monitoring tool for Windows 
- Displays real-time file system, Registry, network  and process/thread activity. 
- Also provides Image load information, meaning if a binary uses Explicit Dynamic LInking, we can see it load the DLL using only Procmon. 
- Procmon is an incredibly powerful tool– so much so– that a lot of malware will look for the presence of Procmon running as an anti-debugging tactic 


---
<!-- slide template="[[Title Slide]]" -->
 ## Demo
Using Procmon on ClickMe.exe 
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Filters for File IO

:::

<!-- element style="font-size: 24px"-->
- Start Procmon and turn off live capture
- Start ClickMe.exe via x64dbg
- Set a filter for Proc name is ClickMe.exe
- Disable Registry, network and processes information
- Make sure File events are enabled
- BP sleep, set RCX=0
- Enable capture
- Run the binary
- Observe the calls to `CreateFile`
- Alternatively, `bp CreateFileA` in x64dbg


---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### 
:::

![[0x08_slide_41_image.png]]




---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### 
:::

![[0x08_slide_42_image.png]]



---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### 
:::

![[0x08_slide_43_image.png]]




---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### 
:::

![[0x08_slide_44_image.png]]


---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### 
:::
![[0x08_slide_45_image.png]]

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Filtering by Operation
:::
![[0x08_slide_46_image.png]]

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### 
:::


![[0x08_slide_47_image.png]]


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Procmon File tips

:::

<!-- element style="font-size: 24px"-->
- Procmon displays a LOT of information when no filters are applied
- Many 
organizations
 will install Sysmon– a system wide implementation of Procmon that will send all of the events to an analysis 
environment
- For us, it is best to run a 
processes
 via x64dbg, turn off capture, and set filters for the target processes, enable capture then run
- Once the processes is done/we are happy with the execution, we can search through the 
mountain
 of data created
- I usually start with all `CreateFile` calls, as they can give information about loaded DLLs, files opened/created


---
<!-- slide template="[[Title Slide]]" -->

### Demo: 
Wannacry with Procmon

:::

---
<!-- slide template="[[Title Slide]]" -->

### Discussion
Hunting  with Procmon/Sysmon

:::

